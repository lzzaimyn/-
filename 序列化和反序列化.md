序列化和反序列化
magic函数 魔术函数
_construct 当一个对象创建时被调用 new MyClass();
__destruct 当一个对象销毁时被调用 代码结束
__toString 当一个对象被当作一个字符串使用 echo $obj;
__serialize() 调用serialize()前执行 PHP 7.4.0 起
__unserialize() 调用unserialize()前执行 PHP 7.4.0 起
__sleep 在对象被序列化之前运行
__wakeup 在对象被反序列化之后被调用
__call() 在对象上下文中调用不可访问的方法时触发
__callStatic() 在静态上下文中调用不可访问的方法时触发
__get() 用于从不可访问的属性读取数据
__set() 用于将数据写入不可访问的属性
__isset() 在不可访问的属性上调用isset()或empty()触发
__unset() 在不可访问的属性上使用unset()时触发
__invoke() 当脚本尝试将对象调用为函数时触发

serialize 方法
Integer i:value; 整型
String s:size:value; 字符串
Boolean b:value;(保存1或0) 布尔
Null N; 空
Array 数组
a:size:{key definition;value definition;(
repeated per element)}
Object 对象
O:strlen(object name):object name:object
size:{s:strlen(property name):property name:
property definition;(repeated per property)}

unserialize 方法 
1、如果传递的字符串不可解序列化，则返回FALSE，并产生一个E_NOTICE
2、返回的是转换之后的值，可为integer``float、string、array或object
3、若被反序列化的变量是一个对象，在成功重新构造对象之后，PHP会自动地试图去调用__wakeup()成员函数（如果存在的话）
4、如果对象没有预定义反序列化得到的对象是__PHP_Incomplete_
Class，并指定了未定义类的类名
用途：传输对象、缓存 session和cookie

__wakeup
__unserialize（7.4.0）
如果类中同时定义了 __unserialize() 和__wakeup() 两个魔术方法，则只有 __unserialize() 方法会生效，__wakeup() 方法会被忽略。

反序列化漏洞产生的条件
1 unserialize函数的参数可控，比如通过GET请求传参（漏洞触发点） 
2、脚本中定义了有Magic方法，方法里面有向php文件做读写数据或者执行命令的操作，比如__destruct()、unlink() 
3、操作的内容需要有对象中的成员变量的值，比如filename

利用方式
序列化一个对象，修改成员变量的值，达到操作其他文件或者执行命令的目的
